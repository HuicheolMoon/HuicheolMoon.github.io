---
layout: post
title: "Today I learned 21.06.20"
category: MEMO
date: 2021-06-20 19:00:00 +0900
---
## CS

### 1. Network

1. HTTP
- 웹 상에서 클라이언트와 서버가 정보를 주고받을 수 있는 TCP/IP 기반 응용 프토로콜
- 주로 HTML 문서를 주고받는 데에 쓰인다.
- TCP(HTTP/1, HTTP/2)와 UDP(HTTP/3)를 사용하며, 80번 포트를 사용한다.
- 비연결 지향
    - 브라우저를 통해 사용자의 요청으로 서버와 접속하여 요청에 대한 응답의 데이터를 전송후, 연결을 종료함. 간단하기 때문에 자원이 적게드는 장점이 있지만, 연결이 지속적이지 않기 때문에 사용자와 연결 종료 후 추가적인 요청시 어떤 사용자의 요청인지 모름. 여러 사용자가 요청할 시 각각의 사용자 요청을 구분할 수 없어서 제대로 된 응답 데이터를 전송할 수 없다는 단점이 있음.
    - 해결 방법으로는 쿠키, 세션, 히든 폼 필드 등이 있음.
- 단방향성
    - 사용자의 요청 한개에 대해 한개의 응답을 하는 방식이기 때문에 서버가 먼저 응답하지 않는다.
- 동작 과정
    - DNS 서버 접속 -> 웹 서버 접속 -> 요청(클라이언트) -> 응답(서버) -> 연결 종료(클라이언트)
    1. **사용자가 웹 브라우저에 URL 주소 입력**
    2. **DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청**
    3. **웹 서버와 TCP 연결 시도 :** 3-way-handshaking
    4. **클라이언트가 서버에게 요청**
        - HTTP Request Message = Request Header + 빈 줄 + Request Body
        - Request Header : 요청 메소드 + 요청 URI + HTTP 프로토콜 버전

            (ex. `GET /background.png HTTP/1.0` `POST / HTTP 1.1`)

            - Header 정보 (key-value 구조)
        - 빈 줄 : 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도
        - Request Body
            - 데이터 업데이트 요청과 관련된 내용 (HTML 폼 콘텐츠 등)
            - GET, HEAD, DELETE, OPTIONS처럼 리소스를 가져오는 요청은 Request Body가 없음.
    5. **서버가 클라이언트에게 데이터 응답**
        - HTTP Response Message = Response Header + 빈 줄 + Response Body
        - Response Header : HTTP 프로토콜 버전 + 응답 코드 + 응답 메시지

            (ex. `HTTP/1.1 404 Not Found.`)

            - Header 정보 (key-value 구조)
        - 빈 줄 : 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도
        - Response Body
            - 응답 리소스 데이터 : 201, 204 상태 코드는 Response Body가 없음.
    6. **서버 클라이언트 간 연결 종료 :** 4-way handshaking
    7. **웹 브라우저가 웹 문서 출력**
- GET과 POST
    - HTTP 프로토콜을 이용해서 서버에 데이터(요청 정보)를 전달할 때 사용하는 방식
    - GET 메서드
        - 정보를 조회. 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메서드 **(Read)**
        - URL의 끝에 '?'가 붙고, 요청 정보가 (key=value)형태의 쌍을 이루어 ?뒤에 이어서 붙어 서버로 전송한다. 요청 정보가 여러 개일 경우에는 '&'로 구분한다.

            ex.) `www.urladdress.xyz?name1=value1&name2=value2`

        - 특징
            - URL에 요청 정보를 붙여서 전송한다. 그렇기 때문에 길이 제한이 있어서 대용량의 데이터를 전송하기 어렵다. (한 번 요청 시 전송 데이터(주솟값 + 파라미터)의 양이 제한됨.(HTTP/1.1은 2048자))
            - 요청 정보를 사용자가 쉽게 눈으로 확인할 수 있다. POST 방식보다 보안상 취약하다.
            - HTTP 패킷의 Body는 비어 있는 상태로 전송한다. 즉, Body의 데이터 타입을 표현하는 'Content-Type' 필드도 HTTP Request Header에 들어가지 않는다.
            - GET 방식은 캐싱을 사용할 수 있어 GET 요청과 그에 대한 응답이 브라우저에 의해 캐쉬된다. 그렇기 때문에 POST 방식보다 빠르다.
    - POST 메서드
        - 요청을 수행. 서버의 값이나 상태를 바꾸기 위한 용도의 메서드 (**Create**)
        - 사용요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다. Request Header의 Content-Type에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다.

            ex.) Default: application/octet-stream, 단순 txt: text/plain, 파일: multipart/form-date

        - 특징
            - Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다.
            - 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다.
            - GET 방식보다 보안상 안전하다.

        Q1. 조회하기 위한 용도로 POST가 아닌 GET 방식을 사용하는 이유?

        1. 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다. (Idempotent, 멱등)
            - GET 방식은 **가져오는 것(Select)**으로, 서버의 데이터나 상태를 변경시키지 않아야 한다.
                - Ex) 게시판의 리스트, 게시글 보기 기능
                - 예외) 방문자의 로그 남기기, 글을 읽은 횟수 증가 기능
            - POST 방식은 **수행하는 것**으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.
                - Ex) 게시판에 글쓰기 기능
        2. 웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 한다.
            - 어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.
            - 즉, 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
            - 이때 POST 방식을 사용할 경우에 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야한다. 그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.
- 문제점
    1. HTTP는 평문 통신이기 때문에 패킷을 수집하는 것만으로 도청이 가능하다.
        1. 통신 자체를 암호화 : `SSL(Secure Socket Layer)` or `TLS(Transport Layer Security)`라는 다른 프로토콜을 조합함으로써 HTTP 의 통신 내용을 암호화할 수 있다. SSL 을 조합한 HTTP 를 `HTTPS(HTTP Secure)` or `HTTP over SSL`이라고 부른다.
        2. 콘텐츠를 암호화 : 말 그대로 HTTP를 사용해서 운반하는 내용인, HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.
    2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
        - 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다.
        - 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다.
        - 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.
        - 어디에서 누가 리퀘스트 했는지 확인할 수 없다.
        - 의미없는 리퀘스트도 수신한다. —> DoS 공격을 방지할 수 없다.
        1. 위 암호화 방법으로 언급된 `SSL`로 상대를 확인할 수 있다. SSL은 상대를 확인하는 수단으로 **증명서**를 제공한다. 증명서는 신뢰할 수 있는 **제 3 자 기관에 의해** 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.
    3. 완전성을 증명할 수 없기 때문에 변조가 가능하다.
        - 여기서 완전성이란 **정보의 정확성**을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 부른다.
        - `MD5`, `SHA-1` 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 `HTTPS`를 사용해야 한다. SSL에는 인증이나 암호화, 다이제스트 기능을 제공하고 있다.

2. HTTPS

- HTTP 통신하는 소켓 부분을 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer)라는 프로토콜로 대체한 것이다. HTTP는 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 된다.
- HTTPS의 SSL에서는 **대칭키 암호화 방식과 공개키 암호화 방식을 모두 사용**한다. 대칭키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 대칭키 암호를 사용하는 방식이다.
- 평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다. 따라서 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있음.
- HTTPS(SSL) 동작 과정
    1. **클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색 (SSL Handshake)**

        1.1. **Client Hello**

        - 클라이언트가 서버에게 전송할 데이터
            - 클라이언트 측에서 생성한 **랜덤 데이터**
            - 클라이언트-서버 암호화 방식 통일을 위해 **클라이언트가 사용할 수 있는 암호화 방식**
            - 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 **세션 아이디**

        1.2. **Server Hello**

        - Client Hello에 대한 응답으로 전송할 데이터
            - 서버 측에서 생성한 **랜덤 데이터**
            - **서버가 선택한 클라이언트의 암호화 방식**
            - **SSL 인증서**

        1.3. **Client 인증 확인**

        - 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고, 목록에 있다면 CA 공개키로 인증서 복호화
        - 클라이언트-서버 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키)
        - pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함)
        - 일련의 과정을 거쳐 session key 생성

        1.4. **Server 인증 확인**

        - 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료)
        - 일련의 과정을 거쳐 session key 생성

        1.5. **Handshaking 종료**

    2. **데이터 전송**
        - 서버와 클라이언트는 session key를 활용해 데이터를 암복호화하여 데이터 송수신
    3. **연결 종료 및 session key 폐기**

    ([https://eun-jeong.tistory.com/27](https://eun-jeong.tistory.com/27))
