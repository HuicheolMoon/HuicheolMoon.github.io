---
layout: post
title: "Today I learned 21.04.22"
category: MEMO
date: 2021-04-22 19:00:00 +0900
---
## Algorithm
### 1. Brute Force
 - dfs를 이용하여 풀이할 수도 있다. 나만의 코드 형식 표준을 만들어서 코드를 빨리 짤 수 있게 하자!

## CS
### 1. 기본 용어
- 인터페이스 : 정보를 교환하는 개체 사이의 경계면 (추상화) (개념)

- API :  응용프로그램이 데이터를 주고 받는 인터페이스 (*사용자는 실제 응용프로그램이 어떻게 돌아가는지 알 필요가 없음. 그저 API가 정한 규약을 따라 데이터를 input하고 원하는 결과를 output으로 받으면 됨. 실제 응용프로그램을 유저 차원에서 추상화시킨 것이 API) (응용프로그램의 겉보기 껍질?)

- 라이브러리 : 특정 기능을 위한 프로그램의 집합 (사용자가 원하는 기능을 라이브러리에서 사용)

- 프레임워크 : 프로그램을 개발하는 데 필요한 요소와 규약을 포함하는 템플릿.  (사용자가 프레임워크에 fit하게 작업)

- 프로토콜 : 데이터 교환 규칙 체계. 기 정의되어있는 형식을 사용

- 아키텍쳐 : 설계도, 설계 지침. 표준을 정의하지 않음.

### 2. RESTful API
- REST : REpresentational State Transfer(표현되는 상태 전달)
    - ROA(Resource Oriented Architecture) - '자원' 중심으로 API 설계하고 '행위'로 자원을 처리하는 설계
    **자원은 URI(Uniform Resource Identifier, 통합 자원 식별자)로 '표현'되고 행위는 HTTP method(GET, POST, PUT, DELETE 등)로 '표현'됨**
    - URI는 Collection(객체 집합)과 Document(객체)로 표현 (ex. http://[restapi.example.com/sports/soccer/players/13](http://restapi.example.com/sports/soccer/players/13), Collection=sports,players, Document=soccer,13)
    - Collection은 복수로, Document는 단수로 표현해준다면 more RESTful

- REST의 6원칙
    1. Uniform Interface(통일된 인터페이스) : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행 (기술과 플랫폼에 관계없이)
    2. Stateless (무상태성) : 작업을 위한 상태정보를 따로 저장하고 관리하지 않음. api는 단순히 들어오는 요청만 처리하면 됨. → 불필요한 정보가 없으므로 구현이 단순해지고 자유도가 높아짐
    3. Cacheable (캐시 가능) : REST는 HTTP를 그대로 사용하므로 HTTP의 캐싱 기능도 이용가능
    4. Client-Server : 클라이언트는 사용자 인증이나 컨텍스트(로그인 정보)를 직접 관리. 서버는 API 제공만을 담당. → 역할이 명확히 구분되어 상호의존성이 감소
    5. Hierarchical system (계층형 구조) : REST 서버는 다중 계층으로 구성될 수 있음 → 보안, 암호화 계층등을 추가해서 구조적으로 유연해지고 게이트웨이 등 네트워크 기반 중간매체 사용 가능
        - proxy : 클라이언트가 자신을 통해 다른 네트워크에 간접적으로 접속할 수 있게 하는 프로그램
        - 게이트웨이 : 서로 다른 프로토콜을 사용하는 네트워크 간 통신을 위한 프로그램
    6. (Optional) Code on Demand (주문형 코드) : 서버가 클라이언트에 표현을 처리하는 코드를 보내주고 실행하게 함. (보안 문제 발생 가능 → 그래서 optional인듯)

- RESTful API
    1. 자원과 행위를 명시적으로 직관적으로 분리 - 자원은 URI로(명사형), 행위는 HTTP method로.
    2. 메시지는 Header(API버전, MIME(전자 우편을 위한 인터넷 표준 포맷) 타입) 와 Body(Entity)로 분리(여기서 header, body와 http의 header.body는 같을 수도 있고, 다를 수도 있고)
    3. API 버전 관리 : 하위호환성 보장 필수
    4. URI의 플랫폼 독립성 : 서버와 클라이언트의 요청이 같은 방식이어야 함.(json/json이든, form-data/form-data든)
        - json : 키-값 쌍 데이터를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷

- RESTful API 장점
    1. Open API 개발, 멀티플랫폼 지원/연동 용이
    2. 교환할 데이터 타입 선택 가능, HTTP 그대로 사용 가능

- RESTful API 단점
    1. method가 제한적(HTTP method만 사용 가능)
    2. 표준이 없음 : 뭐가 진짜 rest인지 공식적으로 정의되지 않음. 사람들간의 약속일 뿐.

- **중요한 점 : 본인의 프로젝트에 맞는 아키텍쳐를 사용하는 것이 맞음. REST를 꼭 따를 필요가 없음. 하지만 REST를 따른다면 여러 장점을 얻을 수 있음. → 개발자의 고민과 선택**

### 3. TDD
- Test-Driven Development(TDD)는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한 후 리팩토링을 통해 코트를 확장시키는 개발 프로세스이다. 말 그대로 테스트가 코드 작성 주도. (기존: 코드 개발 → 테스트 → 배포or수정 반복 / TDD: 테스트 작성 → 만족하는 코드 개발 → 리팩토링 → 테스트/리팩토링 반복)

- 기능의 요구에 대한 집중 : 기능을 개발하기 전에 테스트 코드를 작성해야 하므로 해당 기능의 요구사항과 명세에 대한 이해가 깊어질 수 밖에 없다.

- 새 기능 추가시 작동성 확인 : 새로운 기능을 추가할 때 기존 기능이 고장난 것을 바로 확인할 수 있음

- 리팩토링 용이 : 기능이 추가될 수록 코드량이 커지면서 좋은 코드를 위한 리팩토링(명명, 확장성, 비즈니스 로직, 예외처리)이 필요함. TDD는 리팩토링 과정에서 부분 코드의 안정성을 계속 확인할 수 있기 때문에 리팩토링의 속도와 효율에 이점을 줌.

- 단점 : 테스트 코드 작성 → 할 일이 더 생긴것. / 테스트코드 작성은 어렵고, 팀웤에선 팀원 모두가 익숙해져야 함. / 모든 상황에 대한 완벽한 테스트는 불가능함. → 그럼 테스트 코드 의미가 있나?

- **결국 TDD도 방향을 알려줄 뿐이고 프로젝트 진행하는 개발자가 취사선택해야함.**

- BDD(Behavior Driven Development) : 함수 단위 테스트가 아닌 시나리오 기반 테스트. TDD에서 나아가서 테스트케이스 각각 자체가 요구사양이 되는 개발방법.

### 4. 함수형 프로그래밍
1. Immutabe data : 값이 변경되지 않음. 값이 변경될 경우, 새로운 객체를 생성하고 변경된 값을 주입하여 반환해야 한다.

2. first class citizen : 함수가 일등시민임. 함수가 함수의 파라미터 및 리턴이 될 수 있고, 이름과 관계없이 고유한 구별이 가능하며, 리터럴(변수에 넣는 변하지 않는 데이터)로 바로 정의 가능

### 5. MVC 패턴

- 애플리케이션을 model(애플리케이션의 기능), view(애플리케이션이 보여지는 모습), controller(사용자의 작동을 받음, model과 view를 분리)로 분리하여 개발하는 방법론.

- model은 모든 데이터를 저장, view는 UI 구현(기능 출력), controller(기능 입력, model과 view의 변경을 모니터링, 다리 역할)만이 다른 요소의 작동에 대해 참조할 수 있음.

- 독립된 기능에 대해 개발할 수 있기 때문에 효율성 증대, 유지보수성 및 확장성, 유연성 증가. 중복코딩 방지.
