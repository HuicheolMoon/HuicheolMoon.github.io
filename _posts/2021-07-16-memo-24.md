---
layout: post
title: "Today I learned 21.07.16"
category: MEMO
date: 2021-07-16 19:00:00 +0900
---
## CS

### 1. DB

1. 데이터베이스를 사용하는 이유
    - 기존에는 파일 시스템을 이용하여 데이터를 관리.(현재도 부분적으로 사용) 각각의 파일 단위로 저장하며 독립적인 애플리케이션과 상호 연동
    - 문제점 : 데이터의 종속성, 중복성, 무결성
2. 데이터베이스의 특징
    1. 데이터의 독립성 : 데이터베이스 및 데이터 파일의 크기를 늘리더라도 응용 프로그램을 수정할 필요가 없음.
    2. 데이터 중복 최소화 : 데이터를 통합해서 관리하여 데이터 중복 해결
    3. 데이터의 보안성 : 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현
    4. 데이터의 일관성 : 연관된 정보를 논리적인 구조로 관리. 변경, 오류로 인한 데이터의 불일치성을 배제
    5. 데이터의 무결성 : 데이터의 유효성 검사를 통해 데이터의 무결성을 구현
3. 데이터베이스의 성능
    - 데이터베이스의 성능 = 디스크 I/O
    - 디스크 I/O : 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것. 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 속도가 결정.
    - 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.(locality)
    - 그러므로 현실의 랜덤 I/O를 DB의 순차 I/O로 변환하여 데이터 접근 성능 향상
4. 인덱스
    - key-value로 레코드의 값과 주소를 저장해둔 추가적인 데이터. 항상 정렬된 상태를 유지.
    - 검색 쿼리마다 모든 데이터를 순회하면 비용이 많이 듬. 자주 검색되는 컬럼에 대해 인덱스 테이블 생성.
    - 장점 : 탐색에 효율적
    - 단점 : 추가, 삭제, 수정이 느림.

        → Write 성능을 희생하고 Read 성능을 높힘. 인덱스를 적절하게 구현할 필요가 있음.

    - Index의 자료구조
        1. B+-Tree
            - 일반적으로 사용. 칼럼 값의 원형 or 일부를 사용하여 인덱싱.
        2. Hash
            - 접근 시간복잡도가 O(1)으로 빠름. but 부등호 연산 WHERE절을 처리하기 어려움. (hash값을 대신 사용하므로) → 데이터에 대소관계 range가 존재하는 경우 대부분 B+-Tree를 사용.
    - Clustered Index
        - 물리적으로 인접한 데이터들을 묶어서 저장하는 형태로 구현. (가까운 데이터들을 동시에 조회하는 경우가 많음)
        - 테이블의 Primary key에 대해서만 적용. (테이블마다 유일함.) Primary key 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현. Primary key가 변경되면 물리적 주소도 변경되어야 하므로 초기에 Primary key 설정 유의.
    - 유의점
        1. 모든 컬럼에 대해 인덱스를 생성하면 안될까 → 인덱스는 INSERT, DELETE, UPDATE 쿼리에서 추가적인 과정 발생.(인덱스 검색 및 갱신) → 성능 손실
        2. 자주 데이터 변경이 일어난다면 매 쿼리마다 정렬로 인한 성능 손실
        3. Index Split : 새로운 데이터가 추가될 때 인덱스가 할당받은 기존 블록이 다 찬 경우 새로운 블록에 인덱스를 기록.

            → (1) 블록의 개수가 늘어날수록 랜덤 I/O의 비중이 늘어남.(데이터 지역성) → 인덱스 효율 감소

            → (2) 새로운 블록에 key를 옮기는 작업마다 Redo가 기록. 과부하.

            → (3) Index Split 동안 해당 블록에 대해 락이 필수적. → DML이 대기. 성능 저하.

        4. DELETE 쿼리를 통해 테이블에서 데이터가 삭제되어도 Index에는 잔재. Index의 성능 하락.
        5. UPDATE : 인덱스는 UPDATE 쿼리에 대해 DELETE 후 INSERT를 진행. 작업 과중.
        6. Cardinality : 최대한 중복도가 낮은(unique) 키를 선정하여 인덱스를 구성해야 함.
