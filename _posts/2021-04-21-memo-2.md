---
layout: post
title: "Today I learned 21.04.21"
category: MEMO
date: 2021-04-21 19:00:00 +0900
---
## Algorithm
### 1. Brute Force
 - Backtracking과 recursion으로 적절하게 풀이 가능! 많이 해봐야 성장한다.

## CS
### 1. OOP
- 객체 지향 프로그래밍
  - 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법 (객체는 상태와 행위를 분리하기 위한 수단이라고 생각!)

- OOP의 장점 : 협업을 할 때 코드를 짜는 속도가 빠르고 유지보수도 편리하여 대형 프로젝트에 적합함.

- OOP의 단점 : 설계 시 많은 시간과 노력이 필요. 속도가 상대적으로 느림. but 장점에 비하면 미미함

- **OOP 5대 원칙(SOLID)**
  1. **단일책임(SRP) : 객체 하나에는 책임(기능) 하나만 그러므로 변경되는 이유도 하나 (ex. 계산기와 GUI)**
  2. **개방폐쇄(OCP) : 확장에는 개방적, but 수정에는 폐쇄적 (ex. 브루들링 이동 구현)**
  3. **리스코브치환(LSP) : 자식은 언제나 부모 대체 가능 (상속성) (ex. 볼마우스→광마우스)**
  4. **인터페이스분리(ISP) : 인터페이스를 분리하여 클라이언트가 사용하는 메소드만 남게. 인터페이스의 SRP (ex. 충돌과 이펙트)**
  5. **의존성역전(DIP) : 추상적이고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존하면 안됨. (ex. (자동차→스노우타이어) → (자동차→타이어←스노우타이어))**

- 클래스 : 특정 책임을 위한 속성과 행위를 변수와 메소드를 정의한 것(추상화를 통한 캡슐화 구현)

- 인스턴스 : 클래스의 정의를 토대로 실제 메모리에 할당된 데이터

- **추상화 : 공통의 속성이나 기능을 묶어 이름을 붙이는 것(클래스를 정의하는 과정) (우리는 print 등 함수 내에서 어떤 로직으로 input을 통해 ouput을 만드는지는 모름. 하지만 print라는 이름으로 input을 화면에 띄우는 함수라는 것을 알 수 있으며 사용 또한 원하는 데이터를 input하기만 하면 결과를 제공해줌.)**

- 캡슐화 : 코드를 재수정 없이 사용하기 위해 클래스를 이용하여 변수와 함수 묶음 (추상화에 따라 자연히 수반되는 과정)

- 상속 : 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것

- 다형성 : 오버라이딩(덮어쓰기), 오버로딩(같은 이름 여러개(로직은 다름))이 가능하다.

- 디자인 패턴 : OOP 설계 시 문제를 피하기 위한 약속 패턴

- 나중에 공부해볼 것
  - getter, setter와 @property
  - is-a와 has-a의 차이
